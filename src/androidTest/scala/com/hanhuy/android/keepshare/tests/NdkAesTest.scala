package com.hanhuy.android.keepshare.tests

import java.io.ByteArrayInputStream
import java.security.MessageDigest

import android.support.test.InstrumentationRegistry
import android.support.test.runner.AndroidJUnit4
import com.hanhuy.android.keepshare.{KeyManager, NdkAESEngine, AesInputStream}
import org.junit.Test
import org.junit.Assert._
import org.junit.runner.RunWith

@RunWith(classOf[AndroidJUnit4])
class NdkAesTest {
  @Test
  def twoBlockCbcDecrypt(): Unit = {
    val ciphertext = Array(
      0xf5,0x8c,0x4c,0x04,0xd6,0xe5,0xf1,0xba,0x77,0x9e,0xab,0xfb,0x5f,0x7b,0xfb,0xd6,0x9c,0xfc,0x4e,0x96,0x7e,0xdb,0x80,0x8d,0x67,0x9f,0x77,0x7b,0xc6,0x70,0x2c,0x7d
    ).map(_.toByte)

    val iv = Array(0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f).map(_.toByte)
    val key = Array(0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4).map(_.toByte)
    val plaintext = Array(0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51).map(_.toByte)

    val lastIV = ciphertext.slice(16,32)
    assertEquals(16, lastIV.length)

    val in = new AesInputStream(new ByteArrayInputStream(ciphertext), key, iv)
    val schedule = Array.ofDim[Int](60)
    NdkAESEngine.scheduleKey(key, schedule)
    assertArrayEquals(iv, in.currentIV)
    assertArrayEquals(schedule, in.keyschedule)
    val buf = Array.ofDim[Byte](32)
    val read = in.read(buf)
    in.close()
    assertArrayEquals(lastIV, in.currentIV)
    val read2 = in.read(buf)
    assertEquals(32, read)
    assertEquals(-1, read2)
    assertArrayEquals(plaintext, buf)
  }
  @Test
  def twoBlockCbcDirectDecrypt(): Unit = {
    val ciphertext = Array(
      0xf5,0x8c,0x4c,0x04,0xd6,0xe5,0xf1,0xba,0x77,0x9e,0xab,0xfb,0x5f,0x7b,0xfb,0xd6,0x9c,0xfc,0x4e,0x96,0x7e,0xdb,0x80,0x8d,0x67,0x9f,0x77,0x7b,0xc6,0x70,0x2c,0x7d
    ).map(_.toByte)

    val iv = Array(0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f).map(_.toByte)
    val key = Array(0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4).map(_.toByte)
    val plaintext = Array(0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51).map(_.toByte)

    val inplace = ciphertext.clone()
    assertArrayEquals(ciphertext, inplace)

    val schedule = Array.ofDim[Int](60)
    NdkAESEngine.scheduleKey(key, schedule)
    val decrypted = Array.ofDim[Byte](32)
    NdkAESEngine.decrypt_cbc(ciphertext, 0, decrypted, 0, ciphertext.length, schedule, key.length * 8, iv)
    NdkAESEngine.decrypt_cbc(inplace, 0, inplace, 0, inplace.length, schedule, key.length * 8, iv)

    assertArrayEquals(plaintext, decrypted)
    assertArrayEquals(plaintext, inplace)
  }

  @Test
  def readAssetStream(): Unit = {
    val ctx = InstrumentationRegistry.getContext
    val plaintext = ctx.getAssets.open("sbt-0.13.6.tgz")
    val ciphertext = ctx.getAssets.open("sbt-0.13.6.tgz.aes")

    val iv = Array(0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f).map(_.toByte)
    val key = Array(0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4).map(_.toByte)

    val in = new AesInputStream(ciphertext, key, iv)

    val buf = Array.ofDim[Byte](32768)
    val plainbuf = Array.ofDim[Byte](32768)

    val sha1 = MessageDigest.getInstance("SHA1")
    Stream.continually(scala.util.Random.nextInt(16384) + 16384) map (in.read(buf, 0, _)) takeWhile (_ != -1) zip Stream.from(0) foreach { case (read, index) =>
      val read2 = plaintext.read(plainbuf, 0, read)
      sha1.update(plainbuf, 0, read)
      val cipher1 = Array.ofDim[Byte](read)
      val plain1 = Array.ofDim[Byte](read)
      System.arraycopy(buf, 0, cipher1, 0, read)
      System.arraycopy(plainbuf, 0, plain1, 0, read)
    }
    val digest = sha1.digest()

    in.close()
    plaintext.close()
    assertEquals("3efd29e51751157777c4e001acc106b8737e0720", KeyManager.hex(digest).toLowerCase)
  }

  @Test
  def readAssetStreamInMemory(): Unit = {
    val ctx = InstrumentationRegistry.getContext
    val plainfd = ctx.getAssets.openFd("sbt-0.13.6.tgz")
    val cipherfd = ctx.getAssets.openFd("sbt-0.13.6.tgz.aes")
    val plainbuffer = Array.ofDim[Byte](plainfd.getDeclaredLength.toInt)
    val decryptedbuffer = Array.ofDim[Byte](plainfd.getDeclaredLength.toInt)
    val plaintext = plainfd.createInputStream()
    val ciphertext = cipherfd.createInputStream()

    val iv = Array(0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f).map(_.toByte)
    val key = Array(0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4).map(_.toByte)

    val r = plaintext.read(plainbuffer)
    plaintext.close()
    plainfd.close()

    assertEquals(plainbuffer.length, r)
    assertEquals("3efd29e51751157777c4e001acc106b8737e0720", KeyManager.sha1(plainbuffer).toLowerCase)
    try {

      val in = new AesInputStream(ciphertext, key, iv)
      var read = 1
      val b = in.read()
      decryptedbuffer(0) = b.toByte
      while (read < decryptedbuffer.length) {
        val r = in.read(decryptedbuffer, read, decryptedbuffer.length - read)
        read += r
      }
      in.close()
    } finally {
      cipherfd.close()
    }
    assertArrayEquals(plainbuffer, decryptedbuffer)
    assertEquals("3efd29e51751157777c4e001acc106b8737e0720", KeyManager.sha1(decryptedbuffer).toLowerCase)
  }
}
